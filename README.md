# :melon: RecSys for Melon playlist continuation



### Introduction

`축 처진 퇴근길을 위한 그루브`, `기분 좋은 밤 산책을 위한 적당한 텐션의 음악`, `무드등 켜고 혼술하며 듣는 감각적인 그루브` ...

이렇게 만들어진 플레이 리스트가 과연 오직 30개의 장르에만 의존할까요?

실제 유저들은 대분류 30개나 소분류 224개보다도 **더 세세하게 음악을 분류할 것**이라고 생각했습니다.

K-means clustering을 통해 **더욱 세분화된 장르 군집 1000개**를 찾고, 각 군집 내에서 상위 노래를 추천합니다.



### Keywords

* K-means clustring
* PCA
* SVD



## :leaves: Embedding Songs and Tags

##### 노래의 meta 정보에 playlist에서 추출한 태그 정보를 이용하여 embedding vector를 생성합니다.



1. Issue data를 년/월로 잘라 총 96개의 범주를 생성

   ##### 결측치 처리

   * 월 정보가 `00` 이거나 `51`인 경우, 또는 년도가 `0000`이거나 `2020`인 노래가 존재한다.
   * 총 2801개의 결측치 중에서 **해당 노래가 포함된 앨범을 찾아** 총 8개의 결측치를 채웠다.
   * 나머지 결측치에 대해서는 정보 손실을 감안하고 `0000/00/00`으로 수정하여 년도 범주와 월 범주에 각각 ` 0000`,`00`을 추가하였다.

   ##### 월로 잡을 수 있는 정보와 년도로 잡을 수 있는 정보는 다르다.

   * 6~7월에는 여름에 듣기 좋은 댄스곡이, 12월에는 크리스마스를 겨냥한 캐롤이 발매된다. 월/계절 정보가 핵심이 된다.
   * 제국의 아이들 등 오래전 아이돌 노래를 위한 플레이 리스트 또는 80년대 추억의 노래 등은 년도 정보가 중요한 역할을 한다.

2. 같은 앨범에 있는지 아닌지에 대한 정보는 사용하지 않았다.

   * 동일 앨범 id를 가진 노래의 갯수에 대해 3분위수(75%)값이 2였다.

     즉 대부분이 다른 앨범에 들어가 있기 때문에 앨범 정보는 유용하지 않다고 판단하였다.

   * 또한 같은 앨범일지라도 다양한 장르와 분위기의 노래가 수록된다. 제외한다.

3. 노래별로 tag를 mapping

   ##### 어떻게?

   * 해당 노래가 속한 playlist를 찾아 tag를 추출한다.
   * 이 때 tag는 train data 전체에서 가장 많이 등장한 상위 110개만을 사용하였다.

4. 소분류, 대분류 정보 30 + 224개



## :leaves: PCA / K-means clustering

* PCA를 통해  총 467개의 feature를 180개로 축소한다. noise에 강건한 모델을 기대해볼 수 있다.



* PCA를 이용하여 180 차원으로 차원 축소. 설명력은 0.94
* 총 70만개의 노래를 Minibatch K-means clustering
  * 1000개의 cluster로 학습
  * batch_size = 10000
  * init_size = 100000 (처음 군집 형성시 사용할 sample 수)





## :leaves: Singular Value Decomposition

#### Train

* playlist의 각 song/tag에 대한 score는 단순 count를 이용한다.
  * ex : playlist A에 cluster 1,2,3에 속하는 노래가 각각 `10번, 30번, 5번` 들어갔다면 rating은` 10, 30, 5`

* latent factor = 512, epoch = 50
* RMSE = 0.2009



#### Prediction

1. query playlist를 one-hot vector로 표현한다.

2. 가장 유사한 playlist를 찾는다.

   * cosine similarity를 사용한다.

3. 해당 playlist에 대해 SVD로 예측된 score를 추출한다.

   * 노래의 경우 각 cluster의 점수를 고려하여 노래를 추출한다.

     ex : cluster 1, 2, 3에 대한 점수가 0.5, 0.3, 0.2 인 경우 각 cluster에서 50개, 30개, 20개를 추천한다.

   * tag의 경우 score를 내림차순 정리하여 상위 10개를 추천한다.





## :leaves: Note

> 추가적으로 분석해보면 좋을 것

* 년도 정보를 더 압축한다.

  * 최근으로 올 수록 노래의 트랜드가 더 빨리 바뀐다. 90~80년대의 노래는 10년 단위로 묶고, 최근으로 올수록 2년/1년/반년 단위로 잘라본다.

* 노래 제목, 플레이 리스트 제목에서 태그를 추측해본다.

* tag 110개를 뽑기 전 형태소 분석을 통해 조사 등을 제거하고 알앤비/R&B 나 팝/POP 등을 하나로 묶어준다.

  * 자주 등장하는 태그를 key로, 해당 태그와 관련 있는 하위 태그를 value로 한 dictionary를 생성하여 tag 추천시 이용해본다.

  * { `알앤비`: `[그루브, R&B, ... ]` , `사랑` : `[달달, 연애, 썸, ... ] ` ,... }
  * 현재는 새로운 tag가 query로 들어오면 유사도를 측정하지 못한다. 새로운 tag에 대해서도 형태소 분석 등을 통해 정제한 후 위 dictionary에서 추천 tag list를 추출하는 방법을 써보자.

* like_cnt 정보를 적극 활용한다.

  * like_cnt는 좋은 implict feedback이다. 좋아요 수가 높을 수록 많은 이들이 '잘 구성된 플레이 리스트' 라고 받아들였을 가능성이 크다.

    즉 해당 플레이 리스트에 대한 신뢰도로 해석할 수도 있다.

  * 기존 model에서는 like_cnt에 log를 씌운 값으로 모델을 생성하였으나 0803버전에서는 단순히 count를 사용했다.

    ( 해당 playlist에 cluster 1,2,3에 속하는 노래가 각각 10번,30번,5번 들어갔다면 rating은 10,30,5로 부여한다. )
